@page "/game"
@using Juego_Galleta.Domain.Entities
@using Juego_Galleta.Domain.Interfaces
@using Juego_Galleta.Application.AI
@rendermode InteractiveServer

<PageTitle>Juego de la Galleta - Dots and Boxes</PageTitle>

<div class="game-container">
    <h1 class="game-title">üéÆ Juego de la Galleta</h1>
    
    @if (!_gameStarted)
    {
        <div class="menu-container">
            <h2>Configuraci√≥n del Juego</h2>
            
            <div class="config-group">
                <label>Tama√±o del Tablero (Radio):</label>
                <select @bind="_selectedRadius" class="form-select">
                    <option value="2">Peque√±o (Radio 2)</option>
                    <option value="3">Mediano (Radio 3)</option>
                    <option value="4">Grande (Radio 4)</option>
                    <option value="5">Extra Grande (Radio 5)</option>
                </select>
            </div>

            <div class="config-group">
                <label>Modo de Juego:</label>
                <select @bind="_selectedGameMode" class="form-select">
                    <option value="1">üë§ Humano vs ü§ñ IA</option>
                    <option value="2">ü§ñ IA vs ü§ñ IA</option>
                    <option value="3">üë§ Humano vs üë§ Humano</option>
                </select>
            </div>

            @if (_selectedGameMode == 1)
            {
                <div class="config-group">
                    <label>Nombre del Jugador:</label>
                    <input type="text" @bind="_player1Name" class="form-input" placeholder="Ingresa tu nombre" maxlength="20" />
                </div>
            }

            @if (_selectedGameMode == 3)
            {
                <div class="config-group">
                    <label>Nombre del Jugador 1:</label>
                    <input type="text" @bind="_player1Name" class="form-input" placeholder="Jugador 1" maxlength="20" />
                </div>
                <div class="config-group">
                    <label>Nombre del Jugador 2:</label>
                    <input type="text" @bind="_player2Name" class="form-input" placeholder="Jugador 2" maxlength="20" />
                </div>
            }

            @if (_selectedGameMode == 1 || _selectedGameMode == 2)
            {
                <div class="config-group">
                    <label>Dificultad de la IA:</label>
                    <select @bind="_selectedDepth" class="form-select">
                        <option value="2">F√°cil (Profundidad 2)</option>
                        <option value="3">Normal (Profundidad 3)</option>
                        <option value="4">Dif√≠cil (Profundidad 4)</option>
                        <option value="5">Experto (Profundidad 5)</option>
                    </select>
                </div>
            }

            <button @onclick="StartGame" class="btn btn-primary btn-lg">üéØ Iniciar Juego</button>
        </div>
    }
    else
    {
        <div class="game-board-container">
            <div class="game-info">
                <div class="score-panel">
                    <div class="player-score @(_gameState.CurrentPlayer == 0 ? "active" : "")">
                        <span class="player-icon">üîµ</span>
                        <span class="player-label">@GetPlayerName(0)</span>
                        <span class="score">@_gameState.Scores[0]</span>
                    </div>
                    <div class="player-score @(_gameState.CurrentPlayer == 1 ? "active" : "")">
                        <span class="player-icon">üî¥</span>
                        <span class="player-label">@GetPlayerName(1)</span>
                        <span class="score">@_gameState.Scores[1]</span>
                    </div>
                </div>

                @if (_gameOver)
                {
                    <div class="game-over-panel">
                        <h2>üéâ ¬°Juego Terminado!</h2>
                        <p class="winner-text">@GetWinnerText()</p>
                        <button @onclick="ResetGame" class="btn btn-success">üîÑ Nuevo Juego</button>
                    </div>
                    
                    <!-- Confeti animado -->
                    <div class="confetti-container">
                        @for (int i = 0; i < 50; i++)
                        {
                            var delay = (i * 0.05);
                            var left = (i * 2);
                            <div class="confetti" style="left: @(left)%; animation-delay: @(delay)s;"></div>
                        }
                    </div>
                }
            </div>

            <div class="board-wrapper">
                <!-- Overlay de IA pensando (flotante) -->
                @if (_isThinking)
                {
                    <div class="thinking-overlay">
                        <div class="thinking-badge">
                            <div class="spinner-small"></div>
                            <span>ü§ñ IA pensando...</span>
                        </div>
                    </div>
                }
                
                <svg width="@_svgWidth" height="@_svgHeight" class="game-board">
                    <!-- Grid Lines (fondo) -->
                    @foreach (var edge in _board.Edges)
                    {
                        var (x1, y1, x2, y2) = GetEdgeCoordinates(edge);
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" 
                              class="grid-line" 
                              stroke-width="1" 
                              stroke="#ddd" />
                    }

                    <!-- Edges (l√≠neas jugables) -->
                    @foreach (var edge in _board.Edges)
                    {
                        var (x1, y1, x2, y2) = GetEdgeCoordinates(edge);
                        var isDrawn = _gameState.EdgesTaken[edge.Id];
                        
                        @if (!isDrawn)
                        {
                            <!-- Invisible clickable area (wider) -->
                            <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" 
                                  stroke="transparent"
                                  stroke-width="20"
                                  @onclick="() => OnEdgeClick(edge)"
                                  style="cursor: pointer; pointer-events: stroke;" />
                        }
                        
                        <!-- Visible line -->
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" 
                              class="@GetEdgeClass(edge.Id)"
                              stroke-width="@(isDrawn ? 6 : 4)" 
                              style="pointer-events: none;" />
                    }

                    <!-- Cells (cuadrados completados con emojis) -->
                    @foreach (var cell in _board.Cells)
                    {
                        var owner = _gameState.CellOwners[cell.Id];
                        if (owner >= 0)
                        {
                            var (cx, cy) = GetCellCenter(cell);
                            var emoji = owner == 0 ? "üîµ" : "üî¥";
                            var fontSize = _cellSize * 0.6;
                            var shouldAnimate = !_animatedCells.Contains(cell.Id);
                            var animClass = shouldAnimate ? "cell-emoji cell-emoji-animate" : "cell-emoji";
                            
                            if (shouldAnimate)
                            {
                                _animatedCells.Add(cell.Id);
                            }
                            
                            <g>
                                <text x="@cx" y="@cy" class="@animClass" text-anchor="middle" dominant-baseline="central" font-size="@fontSize">@emoji</text>
                            </g>
                        }
                    }

                    <!-- Vertices (puntos) -->
                    @foreach (var vertexIdx in _vertexPositions.Keys)
                    {
                        var (x, y) = GetVertexCoordinates(vertexIdx);
                        <circle cx="@x" cy="@y" r="5" class="vertex" />
                    }
                </svg>
            </div>

            <div class="controls">
                <button @onclick="ResetGame" class="btn btn-secondary">üè† Men√∫ Principal</button>
            </div>
        </div>
    }
</div>

@code {
    private Board _board = null!;
    private GameState _gameState = null!;
    private IEvaluator _evaluator = null!;
    private ISearchStrategy _searchStrategy = null!;
    
    // For rendering
    private Dictionary<int, (int x, int y)> _vertexPositions = new();
    private int[] _edgeOwners = null!; // Track which player drew each edge
    private HashSet<int> _animatedCells = new(); // Track which cells have been animated
    
    private bool _gameStarted = false;
    private bool _gameOver = false;
    private bool _isThinking = false;
    
    private int _selectedRadius = 3;
    private int _selectedGameMode = 1;
    private int _selectedDepth = 3;
    
    private bool _isPlayer1AI = false;
    private bool _isPlayer2AI = false;
    
    // Player names
    private string _player1Name = "";
    private string _player2Name = "";

    // SVG parameters
    private const int _cellSize = 60;
    private const int _padding = 40;
    private int _svgWidth = 600;
    private int _svgHeight = 600;

    private void StartGame()
    {
        // Generate board
        var factory = new GalletaShapeFactory(_selectedRadius);
        _board = factory.Build();
        _gameState = new GameState(_board, 0);
        
        // Initialize edge owners (-1 means not drawn yet)
        _edgeOwners = new int[_board.Edges.Count];
        Array.Fill(_edgeOwners, -1);
        
        // Reset animated cells tracker
        _animatedCells.Clear();
        
        // Set default names if not provided
        if (string.IsNullOrWhiteSpace(_player1Name))
            _player1Name = _selectedGameMode == 1 ? "Jugador" : "Jugador 1";
        if (string.IsNullOrWhiteSpace(_player2Name))
            _player2Name = _selectedGameMode == 2 ? "IA 2" : (_selectedGameMode == 1 ? "IA" : "Jugador 2");
        
        // Calculate vertex positions
        CalculateVertexPositions();
        
        // Configure AI
        _evaluator = new SimpleDotsEvaluator();
        _searchStrategy = new MinimaxAlphaBeta(_evaluator);
        
        // Configure game mode
        switch (_selectedGameMode)
        {
            case 1: // Human vs AI
                _isPlayer1AI = false;
                _isPlayer2AI = true;
                break;
            case 2: // AI vs AI
                _isPlayer1AI = true;
                _isPlayer2AI = true;
                _player1Name = "IA 1";
                _player2Name = "IA 2";
                break;
            case 3: // Human vs Human
                _isPlayer1AI = false;
                _isPlayer2AI = false;
                break;
        }

        // Calculate SVG size
        CalculateSVGSize();
        
        _gameStarted = true;
        _gameOver = false;

        // If first player is AI, make move
        if (_isPlayer1AI)
        {
            _ = MakeAIMove();
        }
    }

    private void CalculateVertexPositions()
    {
        // Use EXACTLY the same logic as GalletaShapeFactory to avoid index mismatches
        var points = new List<(int x, int y)>();
        
        // Generate points row by row - top half (including middle)
        for (int y = -_selectedRadius; y <= 0; y++)
        {
            // Calculate how many cells wide this row should be
            int distFromCenter = Math.Abs(y);
            int halfWidth = _selectedRadius - distFromCenter;
            
            // Generate points from left edge to right edge of the diamond at this row
            for (int x = -halfWidth; x <= halfWidth + 1; x++)
            {
                points.Add((x, y));
            }
            
            // If this is the widest row (center), add an extra row below it
            if (y == 0)
            {
                for (int x = -halfWidth; x <= halfWidth + 1; x++)
                {
                    points.Add((x, y + 1));
                }
            }
        }
        
        // Generate points row by row - bottom half (starting after the extra row)
        for (int y = 2; y <= _selectedRadius + 1; y++)
        {
            // Calculate how many cells wide this row should be
            int distFromCenter = y - 1; // Distance from the extra middle row
            int halfWidth = _selectedRadius - distFromCenter;
            
            // Generate points from left edge to right edge of the diamond at this row
            for (int x = -halfWidth; x <= halfWidth + 1; x++)
            {
                points.Add((x, y));
            }
        }
        
        // Create mapping (points are already in order)
        _vertexPositions.Clear();
        for (int i = 0; i < points.Count; i++)
        {
            _vertexPositions[i] = (points[i].x, points[i].y);
        }
    }

    private void CalculateSVGSize()
    {
        int maxX = 0, maxY = 0;
        foreach (var (x, y) in _vertexPositions.Values)
        {
            if (Math.Abs(x) > maxX) maxX = Math.Abs(x);
            if (Math.Abs(y) > maxY) maxY = Math.Abs(y);
        }
        
        _svgWidth = (maxX * 2 + 1) * _cellSize + _padding * 2;
        _svgHeight = (maxY * 2 + 1) * _cellSize + _padding * 2;
    }

    private async Task OnEdgeClick(Edge edge)
    {
        if (!CanPlayEdge(edge)) return;
        
        var move = new Move(edge.Id);
        MakeMove(move);
        
        // If game not over and next player is AI, make AI move
        if (!_gameOver && IsCurrentPlayerAI())
        {
            await MakeAIMove();
        }
    }

    private void MakeMove(Move move)
    {
        // Record which player made this move
        _edgeOwners[move.EdgeId] = _gameState.CurrentPlayer;
        
        _gameState.Apply(move);
        
        if (_gameState.IsTerminal())
        {
            _gameOver = true;
        }
    }

    private async Task MakeAIMove()
    {
        _isThinking = true;
        StateHasChanged();
        
        await Task.Delay(500); // Small delay for visual effect
        
        var move = _searchStrategy.GetBestMove(_gameState, _gameState.CurrentPlayer, _selectedDepth);
        MakeMove(move);
        
        _isThinking = false;
        StateHasChanged();
        
        // Check if game is over
        if (_gameOver) return;
        
        // If current player is still AI (captured a cell), continue playing
        if (IsCurrentPlayerAI())
        {
            await Task.Delay(800); // Slightly longer delay between consecutive moves
            await MakeAIMove();
        }
        // For AI vs AI mode, if next player is also AI, continue
        else if (_selectedGameMode == 2)
        {
            await Task.Delay(1000);
            await MakeAIMove();
        }
    }

    private bool IsCurrentPlayerAI()
    {
        return _gameState.CurrentPlayer == 0 ? _isPlayer1AI : _isPlayer2AI;
    }

    private bool CanPlayEdge(Edge edge)
    {
        if (_gameOver || _isThinking) return false;
        if (_gameState.EdgesTaken[edge.Id]) return false;
        if (IsCurrentPlayerAI()) return false;
        return true;
    }

    private string GetEdgeClass(int edgeId)
    {
        var owner = _edgeOwners[edgeId];
        if (owner == -1) return "edge-available";
        return owner == 0 ? "edge-player1" : "edge-player2";
    }

    private (int x, int y) GetVertexCoordinates(int vertexIndex)
    {
        var (gridX, gridY) = _vertexPositions[vertexIndex];
        int centerX = _svgWidth / 2;
        int centerY = _svgHeight / 2;
        
        int x = centerX + gridX * _cellSize;
        int y = centerY + gridY * _cellSize;
        
        return (x, y);
    }

    private (int x1, int y1, int x2, int y2) GetEdgeCoordinates(Edge edge)
    {
        var (x1, y1) = GetVertexCoordinates(edge.VertexA);
        var (x2, y2) = GetVertexCoordinates(edge.VertexB);
        return (x1, y1, x2, y2);
    }

    private (int cx, int cy) GetCellCenter(Cell cell)
    {
        // Get the 4 edges of the cell
        var edges = _board.CellEdges[cell.Id];
        
        // Collect all vertices from these edges
        var vertexSet = new HashSet<int>();
        foreach (var edgeId in edges)
        {
            var edge = _board.Edges[edgeId];
            vertexSet.Add(edge.VertexA);
            vertexSet.Add(edge.VertexB);
        }
        
        // Calculate center from actual SVG coordinates (not grid positions)
        int sumX = 0, sumY = 0;
        foreach (var vertexIdx in vertexSet)
        {
            var (x, y) = GetVertexCoordinates(vertexIdx);
            sumX += x;
            sumY += y;
        }
        
        int cx = sumX / vertexSet.Count;
        int cy = sumY / vertexSet.Count;
        
        return (cx, cy);
    }

    private string GetPlayerName(int playerIndex)
    {
        return playerIndex == 0 ? _player1Name : _player2Name;
    }

    private string GetWinnerText()
    {
        if (_gameState.Scores[0] > _gameState.Scores[1])
            return $"üèÜ ¬°{_player1Name} Gana!";
        else if (_gameState.Scores[1] > _gameState.Scores[0])
            return $"üèÜ ¬°{_player2Name} Gana!";
        else
            return "ü§ù ¬°Empate!";
    }

    private void ResetGame()
    {
        _gameStarted = false;
        _gameOver = false;
        _isThinking = false;
        _player1Name = "";
        _player2Name = "";
    }
}
